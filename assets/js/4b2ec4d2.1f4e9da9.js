"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[230],{2494:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var s=n(4848),a=n(8453);const r={sidebar_position:1},o="Overview",i={id:"design/overview",title:"Overview",description:"The Nuffle Fast Finality Layer (NFFL, formerly SFFL) aims to provide a fast settlement",source:"@site/docs/design/overview.md",sourceDirName:"design",slug:"/design/overview",permalink:"/design/overview",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"sidebar",previous:{title:"Protocol Design",permalink:"/category/protocol-design"},next:{title:"Messaging and Checkpoints",permalink:"/design/messaging_and_checkpoints"}},h={},l=[{value:"Architecture",id:"architecture",level:2},{value:"Ethereum",id:"ethereum",level:3},{value:"NEAR Data Availability",id:"near-data-availability",level:3},{value:"NFFL off-chain nodes",id:"nffl-off-chain-nodes",level:3},{value:"Network Registry",id:"network-registry",level:3},{value:"Checkpoint Tasks",id:"checkpoint-tasks",level:3},{value:"User Flow",id:"user-flow",level:3}];function c(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(t.p,{children:"The Nuffle Fast Finality Layer (NFFL, formerly SFFL) aims to provide a fast settlement\nlayer that allows participating networks to quickly access information from\nother networks in a safe way."}),"\n",(0,s.jsxs)(t.p,{children:["In order to achieve this, NFFL leverages both ",(0,s.jsx)(t.a,{href:"https://near.org",children:"NEAR"})," and\n",(0,s.jsx)(t.a,{href:"https://www.eigenlayer.xyz",children:"EigenLayer"}),", providing not only a way for\nprotocols to provide interoperability features by verifying state attestations\nsecured by staked ETH."]}),"\n",(0,s.jsxs)(t.p,{children:["The architecture is comprised of two off-chain actors, the ",(0,s.jsx)(t.em,{children:"Operators"})," and the\n",(0,s.jsx)(t.em,{children:"Aggregator"}),", the AVS nodes, and multiple on-chain contracts:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"on Ethereum Mainnet, there's the NFFL AVS contract set, which interacts\ndirectly with EigenLayer contracts."}),"\n",(0,s.jsx)(t.li,{children:"on rollup networks, there are NFFL verifier contracts to check\nnetwork state attestations."}),"\n",(0,s.jsx)(t.li,{children:"on NEAR, there is a NEAR DA contract for each participating rollup network\nwhich serves as a medium for storing historical block data."}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"architecture",children:"Architecture"}),"\n",(0,s.jsxs)(t.p,{children:["Below is a diagram representation of NFFL's architecture. Let's consider, as an\nexample, ",(0,s.jsx)(t.code,{children:"HelloProtocol"}),", a very primitive protocol in which users want to send\nand receive ",(0,s.jsx)(t.em,{children:"hello"})," from one network to another. In abstract terms, this is the\nbase feature of every bridging protocol. It's a good idea to refer to this\ndiagram whenever any of the interactions seems unclear."]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Full Architecture Overview",src:n(7583).A+"",width:"5442",height:"3418"})}),"\n",(0,s.jsx)(t.h3,{id:"ethereum",children:"Ethereum"}),"\n",(0,s.jsxs)(t.p,{children:["NFFL's is enabled to provide the fast finality guarantees by leveraging the\narchitecture of EigenLayer ",(0,s.jsx)(t.em,{children:"Actively Valildated Service"}),". EigenLayer AVS\nallows the coordination of validators in distributed network towards a common\ngoal. EigenLayer allows validators to reuse Ethereum stake as the mechanism\nfor incentivization."]}),"\n",(0,s.jsxs)(t.p,{children:["In order for NFFL to have economic security, users must first restake ETH into\nEigenLayer, becoming ",(0,s.jsx)(t.em,{children:"Restakers"}),". This means the NFFL architecture actually\nstarts on Ethereum, as the\n",(0,s.jsx)(t.a,{href:"https://github.com/Layr-Labs/eigenlayer-contracts/tree/dev/docs",children:"EigenLayer core contracts"}),"\nlive there."]}),"\n",(0,s.jsxs)(t.p,{children:["The NFFL has a set of smart contracts which, in EigenLayer terms, are called\n",(0,s.jsx)(t.em,{children:"middleware"}),". The ",(0,s.jsx)(t.em,{children:"middleware"})," contracts are directly connected to the\nEigenLayer core contracts. The AVS contracts facilitate the interaction between\nthe off-chain node with the EigenLayer protocol. Operations such as registering\nas an ",(0,s.jsx)(t.em,{children:"Operator"})," (a validator) and validating task resolutions are handled by\nthe AVS contracts. ",(0,s.jsx)(t.em,{children:"Restakers"})," can delegate their restaked Eth to ",(0,s.jsx)(t.em,{children:"Operators"}),",\nwho will then validate the AVS on their behalf."]}),"\n",(0,s.jsx)(t.h3,{id:"near-data-availability",children:"NEAR Data Availability"}),"\n",(0,s.jsx)(t.p,{children:"To settle rollup transactions on NEAR, participating rollups must post block\ndata to NEAR. NEAR DA is the data availability solution used for hosting the\nrollup block data."}),"\n",(0,s.jsx)(t.p,{children:"The data posted to NEAR DA is indexed by the AVS nodes. The nodes compare the\nposted blocks with their own full nodes' data and agree on the network state."}),"\n",(0,s.jsxs)(t.p,{children:["The role of posting block data to NEAR DA is separated from the rollup\nsequencer, into a ",(0,s.jsx)(t.em,{children:"Relayer"})," role. This Relayer constantly posts block data to\nNEAR DA, providing a fast and public ledger to the current network state.\nThe separation of the Relayer allows for participating rollups to use the\nfast finality layer without any modifications to their sequencer implementation."]}),"\n",(0,s.jsxs)(t.p,{children:["Since the AVS nodes compare the data posted by the Relayer with their local\nfull nodes, this doesn't mean the AVS will necessarily agree with it even if\nthe ",(0,s.jsx)(t.em,{children:"Relayer"})," acts maliciously"]}),"\n",(0,s.jsx)(t.p,{children:"There's an example Relayer implementation, but it should slightly change\ndepending on the specific network and stack, as it should ideally be operated\nby the sequencer."}),"\n",(0,s.jsx)(t.h3,{id:"nffl-off-chain-nodes",children:"NFFL off-chain nodes"}),"\n",(0,s.jsx)(t.p,{children:"NFFL nodes attest to the state root of rollup after executing the block. The\nindividual signatures are aggregated off-chain and submitted to Ethereum and\nparticipating rollups."}),"\n",(0,s.jsx)(t.p,{children:"An NFFL Operator, runs a full node for each of the participant networks\n(including Ethereum), as well as a NEAR full node and a NEAR DA indexer. The\nsimplified flow can be described through the following:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"The indexer captures a block posted to NEAR DA for one of the networks and\nsends it to the operator node."}),"\n",(0,s.jsx)(t.li,{children:"The operator node retrieves and parses the block."}),"\n",(0,s.jsxs)(t.li,{children:["The operator node checks if the block is the same as the one in their\nself-hosted network full node.","\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"If the blocks do not match, then the block posted by the Relayer are\nwrong and the NFFL nodes do not sign any state root."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(t.li,{children:"The operator node, through their BLS keypair, signs a message attesting\nthat, for the network in question in that block height, the state root is the\none that was fetched."}),"\n",(0,s.jsx)(t.li,{children:"The operator sends the signed message to the Aggregator."}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The Aggregator collects BLS signatures from multiple NFFL nodes. When\nthe desired quorum of operator power (i.e. restaked amount) is reached, then\nall of the signatures are aggregated into one and made available through an\nAPI."}),"\n",(0,s.jsxs)(t.p,{children:['This aggregated signature, when validated by a program that has access to the\noperator set, is the equivalent of "',(0,s.jsxs)(t.em,{children:["A sufficient amount of operators have\nagreed that, for network ",(0,s.jsx)(t.code,{children:"N"}),", at block height ",(0,s.jsx)(t.code,{children:"H"}),", the state root is ",(0,s.jsx)(t.code,{children:"S"})]}),'".\nBy verifying the aggregated signatures a rollup can be sure of other rollup,\nallowing seamless cross-chain interoperability!']}),"\n",(0,s.jsxs)(t.p,{children:["Apart from voting on the state roots of rollups, NFFL operators also track\noperator set updates on the AVS contracts and emit attestations for those in a\nsomehow similar process - instead of expecting block data externally, it simply\nsubscribes to Ethereum updates through its full node. The importance of that\nwill be discussed in ",(0,s.jsx)(t.a,{href:"#network-registry",children:"Network Registry"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["For more details on the messaging flow, please read\n",(0,s.jsx)(t.a,{href:"/design/messaging_and_checkpoints",children:"Messaging and Checkpoints"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"network-registry",children:"Network Registry"}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.em,{children:"Registry"})," contract is a vital component of the NFFL architecture.\nThere is a ",(0,s.jsx)(t.em,{children:"Registry"})," contract on each rollup. This contract is used to verify\nthe state root attestations."]}),"\n",(0,s.jsx)(t.p,{children:"In order to verify the signature, the Registry contract have access to the AVS\noperator set - otherwise, it can't know if a signer is an operator or not, much\nless whether the attestation has passed quorum or not."}),"\n",(0,s.jsx)(t.p,{children:"In fact NFFL Registry contracts have two roles - 1) store a copy of the\noperator set and 2) verifying attestations. To keep the operator set\nup to date, the Registry contract accepts attestations for operator set updates."}),"\n",(0,s.jsx)(t.p,{children:"The operator set relies on the AVS attestations to be\nup-to-date - the AVS operators themselves agree on each operator set delta.\nThis is an easily verifiable 'task' in terms of slashing, and implements the\ncross-chain messaging necessary for communicating this from Ethereum to the\nother participant networks."}),"\n",(0,s.jsx)(t.p,{children:"The operator set update is an Aggregator task by initially, but it would not be\nrestricted to it - any user can submit it. Changes to this mechanism,\nespecially in terms of economic incentives, are planned."}),"\n",(0,s.jsx)(t.h3,{id:"checkpoint-tasks",children:"Checkpoint Tasks"}),"\n",(0,s.jsxs)(t.p,{children:["As defined in the ",(0,s.jsx)(t.a,{href:"https://docs.eigenlayer.xyz/eigenlayer/avs-guides/first-steps-towards-designing-an-avs",children:"EigenLayer AVS guidelines"}),",\nAVS operation should be represented in terms of units of work called ",(0,s.jsx)(t.em,{children:"Tasks"}),".\nThese tasks are defined in the AVS contracts on Ethereum. The AVS payment and\nslashing are based on the operators fulfilling these tasks in a correct manner."]}),"\n",(0,s.jsxs)(t.p,{children:["In the NFFL architecture, the attestations defined above are not defined as a\n",(0,s.jsx)(t.em,{children:"Task"})," - rather, they are defined as ",(0,s.jsx)(t.em,{children:"Messages"}),". The ",(0,s.jsx)(t.em,{children:"Task"})," for NFFL nodes is\ndefined as the amalgamation of all the ",(0,s.jsx)(t.em,{children:"Message"})," types, specifically the unit\nof work required from all validators is to attest on the aggregation\n(more specifically ",(0,s.jsx)(t.em,{children:"Merkleization"}),") of messages in a time range."]}),"\n",(0,s.jsx)(t.p,{children:"Using the merkleization of aggregated messages, the existance or non-existance\nof a message in a time range is verified on Ethereum through the task response.\nThe verification of the aggregated message is used for slashing and payment\nprocessing."}),"\n",(0,s.jsxs)(t.p,{children:["For more details on checkpoints, refer to\n",(0,s.jsx)(t.a,{href:"/design/messaging_and_checkpoints",children:"Messaging and Checkpoints"}),"."]}),"\n",(0,s.jsx)(t.h3,{id:"user-flow",children:"User Flow"}),"\n",(0,s.jsx)(t.p,{children:"Finally - how can NFFL be used by a user or protocol? The integration is\nactually quite simple. Let's follow the HelloProtocol example: consider a user\nhad sent a \"hello!\" message on Network #2 to Network #1, recording it on\nNetwork #2's state."}),"\n",(0,s.jsx)(t.p,{children:"Eventually, the block in which the message was submitted gets considered in\nNFFL and a state root attestation was collected for the Network #2's state.\nThrough it, anyone can submit the attestation to any network, not only Network\n#1, making Network #2's state available on it."}),"\n",(0,s.jsx)(t.p,{children:"The HelloProtocol (off-chain) app would then keep track of NFFL's state and,\nas such, would be able to fetch this attestation as soon as it's available.\nThis complexity can be simply abstracted from the user."}),"\n",(0,s.jsx)(t.p,{children:'When the attestation is done, the protocol lets the user consume the "hello!"\non Network #1 by sumbitting a transaction that indicates the storage proof\nof the message on Network #2 and the attestation from NFFL. Again, the UX is\nnot really impacted - the proof should also be generated in the background.'}),"\n",(0,s.jsx)(t.p,{children:'This data is then relayed by the HelloProtocol contract to the NFFL Registry\ncontract, which validates the attestation and checks the storage proof - and\nthere is our "hello!"!'}),"\n",(0,s.jsx)(t.p,{children:"In easier and UX terms, all of the parts of this integration, that\nmay seem strange to the user, can be simply abstracted from them. In\nimplementation terms, it's a matter of fetching the attestation and the proof,\nas well as linking the protocol's contracts to NFFL's and relaying the fetched\ndata."})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},7583:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/full_architecture_overview.excalidraw-eb1f4dc81123be077475d2de7e82872c.svg"},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var s=n(6540);const a={},r=s.createContext(a);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);