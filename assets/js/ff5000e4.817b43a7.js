"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[91],{8619:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var o=n(4848),i=n(8453);const r={sidebar_position:6},s="Incentives",a={id:"design/incentives",title:"Incentives",description:"Please refer to Overview for an introduction.",source:"@site/docs/design/incentives.md",sourceDirName:"design",slug:"/design/incentives",permalink:"/design/incentives",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"sidebar",previous:{title:"Faults",permalink:"/design/faults"},next:{title:"Operator",permalink:"/category/operator"}},l={},c=[{value:"Operating the Network",id:"operating-the-network",level:2},{value:"Relaying Block Data to NEAR DA",id:"relaying-block-data-to-near-da",level:2},{value:"Pushing Operator Set Updates to Networks",id:"pushing-operator-set-updates-to-networks",level:2},{value:"Challenging a Checkpoint",id:"challenging-a-checkpoint",level:2}];function h(e){const t={a:"a",admonition:"admonition",em:"em",h1:"h1",h2:"h2",p:"p",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"incentives",children:"Incentives"}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsxs)(t.p,{children:["Please refer to ",(0,o.jsx)(t.a,{href:"/design/overview",children:"Overview"})," for an introduction."]})}),"\n",(0,o.jsx)(t.p,{children:"The incentive structure of the protocol is in the design phase, we will now\ndiscuss the factors that will inform the reward scheme and slashing design."}),"\n",(0,o.jsx)(t.h2,{id:"operating-the-network",children:"Operating the Network"}),"\n",(0,o.jsx)(t.p,{children:"To design the optimal incentive structure for NFFL AVS, we must understand the\ncosts of the NFFL nodes to run the protocol."}),"\n",(0,o.jsx)(t.p,{children:"The NFFL nodes stake Ethereum by getting delegations from staked Ethereum\nholders. In addition to the stake run off-chain software, namely 1) rollup full\nnodes 2) NFFL nodes and 3) Aggregator node. As such, it's vital for the\nprotocol to reward the Operators accordingly."}),"\n",(0,o.jsxs)(t.p,{children:["The calculation for the rewards for an Operator must be based on the signed\n",(0,o.jsx)(t.a,{href:"/design/messaging_and_checkpoints",children:"Checkpoint Tasks"}),". Once the challenge\nperiod passes for the ",(0,o.jsx)(t.em,{children:"Task"}),", anyone can submit a ZK proof proving the message\ncount and the participation rate of each Operator, collecting a reward in the\nprocess (i.e. triggering the payment system should also be incentivised)."]}),"\n",(0,o.jsx)(t.h2,{id:"relaying-block-data-to-near-da",children:"Relaying Block Data to NEAR DA"}),"\n",(0,o.jsxs)(t.p,{children:["Each participating network has a Relayer, that feeds the network blocks to NEAR\nDA as they're produced. As discussed in the\n",(0,o.jsx)(t.a,{href:"/design/overview#near-data-posting",children:"Overview section"}),",\nthe Relayer role can be fulfilled by a decentralised network."]}),"\n",(0,o.jsxs)(t.p,{children:["Independent of what the Relayer implementation looks like, the Relayer needs to\npay $NEAR to submit blocks to\n",(0,o.jsx)(t.a,{href:"https://github.com/Nuffle-Labs/data-availability",children:"NEAR DA"}),". The rewards for the\nRelayer at the least need to compensate the Relayer's fee expenditure."]}),"\n",(0,o.jsx)(t.p,{children:"In this specific case, it should be a reasonable approach that each network\nincentivises their Relayers independently, as it's effectively an extra DA\nlayer for the network - so it's directly beneficial for it. However, a\nmechanism for NFFL itself to reward Relayers could also be implemented."}),"\n",(0,o.jsx)(t.h2,{id:"pushing-operator-set-updates-to-networks",children:"Pushing Operator Set Updates to Networks"}),"\n",(0,o.jsxs)(t.p,{children:["As discussed in ",(0,o.jsx)(t.a,{href:"/design/operator_set_tracking",children:"Operator Set Tracking"}),", every\nparticipating rollup network has a copy of the operator set. The operator set\nis kept to update with the operator set on Ethereum. There might be some\nsynchronisation issues with the cross-chain interoperability. Theo minimise a\ndifference in the operator set, the protocol should have an incentive mechanism."]}),"\n",(0,o.jsx)(t.h2,{id:"challenging-a-checkpoint",children:"Challenging a Checkpoint"}),"\n",(0,o.jsxs)(t.p,{children:["All checkpoints published to Ethereum can be challenged. The protocol when\ninstantiated will set a challenge period for the checkpoints, during which\nanyone can submit a fraud proof. The fraud proof would need to prove one of the\nfaults described in the ",(0,o.jsx)(t.a,{href:"/design/faults",children:"Faults"})," section. Constructing fraud proof\nis potentially a costly process, therefore the challenger should be rewarded\nfor submitting a valid fraud proof. Ideally, in case of a successful challenge,\na fixed amount of rewards on Ethereum should be readily available to\nchallengers to both cover transaction costs and make it profitable to scan for\nfaults."]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var o=n(6540);const i={},r=o.createContext(i);function s(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);