"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[65],{4692:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var r=n(4848),s=n(8453);const i={sidebar_position:4},o="Operator Set Tracking",a={id:"design/operator_set_tracking",title:"Operator Set Tracking",description:"Please refer to Overview for an introduction.",source:"@site/docs/design/operator_set_tracking.md",sourceDirName:"design",slug:"/design/operator_set_tracking",permalink:"/design/operator_set_tracking",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"sidebar",previous:{title:"Network Management",permalink:"/design/network_management"},next:{title:"Faults",permalink:"/design/faults"}},d={},c=[{value:"Operator Set Updates",id:"operator-set-updates",level:2},{value:"Syncing",id:"syncing",level:2},{value:"Operator Entry/Exit Queue",id:"operator-entryexit-queue",level:3},{value:"Changing the Signature Architecture to ECDSA",id:"changing-the-signature-architecture-to-ecdsa",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"operator-set-tracking",children:"Operator Set Tracking"}),"\n",(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsxs)(t.p,{children:["Please refer to ",(0,r.jsx)(t.a,{href:"/design/overview",children:"Overview"})," for an introduction."]})}),"\n",(0,r.jsx)(t.h2,{id:"operator-set-updates",children:"Operator Set Updates"}),"\n",(0,r.jsx)(t.p,{children:"Operator set updates are block-based changes in the operator set which are used\nby the NFFL operators in order to update networks' operator sets."}),"\n",(0,r.jsx)(t.p,{children:"An operator set update is comprised of all the updates in operator weights in\none block, and as such happens at most once a block. It also has an\nincrementing ID - which is then used on the attestation message and that can be\nused to fetch the update content for verifying evidences on bad messages."}),"\n",(0,r.jsxs)(t.p,{children:["This design and tracking logic is mostly implemented in the\n",(0,r.jsx)(t.code,{children:"SFFLOperatorSetUpdateRegistry"})," contract."]}),"\n",(0,r.jsx)(t.h2,{id:"syncing",children:"Syncing"}),"\n",(0,r.jsx)(t.p,{children:"The goal of standardizing and attesting operator set updates is to make it\npossible that each participating network has a copy of the operator set locally\nso it can verify attestations."}),"\n",(0,r.jsx)(t.p,{children:"Since the operator set updates need to be propagated between different\nnetworks, the updates can't be done in an synchronous manner. There might be\nshort periods of asynchrony where the operator set on a rollup might diverge\nfrom the one on Ethereum. This is especially problematic for verifying\nattestations, as a different operator set may lead to the attestation, which is\nbased on an aggregated signature that used the current operator set as\nreference, not being verifiable. This could happen both when the attestation is\nbased on the current operator set, in which case it should be verifiable in a\nshort time, and also when it's based on a previous operator set, which means\nit's likely simply not verifiable and the user would need to get a current\nattestation."}),"\n",(0,r.jsx)(t.p,{children:"There are two planned approaches to mitigate this issue: adding an entry/exit\nqueue to the operator set and changing the signature architecture to ECDSA."}),"\n",(0,r.jsx)(t.h3,{id:"operator-entryexit-queue",children:"Operator Entry/Exit Queue"}),"\n",(0,r.jsx)(t.p,{children:"The entry/exit queue sets an upper bound on the effective operator set updates.\nThis would not only make it so rollup networks need to be updated less often\nbut also that the case in which messages would not be verifiable for a short\nperiod of time would happen more rarely."}),"\n",(0,r.jsx)(t.p,{children:"An addition to this, as the frequency would be pre-determined, could be storing\na fixed number the past operator sets instead of only the current operator set\nin the secondary networks. This way, messages from the previous operator sets\nwould still be verifiable and the UX could be greatly improved in case of late\ntransactions or such."}),"\n",(0,r.jsx)(t.h3,{id:"changing-the-signature-architecture-to-ecdsa",children:"Changing the Signature Architecture to ECDSA"}),"\n",(0,r.jsxs)(t.p,{children:["The default signature architecture for AVSs is BLS, because it makes verifying\nmultiple signatures cheaper through aggregation. Instead of ",(0,r.jsx)(t.code,{children:"N"})," signatures,\nonly one signature needs to be verified, in the best case. More specifically,\nthe scaling turns from ",(0,r.jsx)(t.code,{children:"O(n)"})," to ",(0,r.jsx)(t.code,{children:"O(m)"}),", where ",(0,r.jsx)(t.code,{children:"n"})," is the number of signers and\n",(0,r.jsx)(t.code,{children:"m"})," is the number of non-signers."]}),"\n",(0,r.jsx)(t.p,{children:"Consequently, when an aggregated BLS signature is checked for quorum, it\nshould include the aggregated public key, the signature, and also the\nnon-signers."}),"\n",(0,r.jsx)(t.p,{children:"The problem with this is that it effectively makes it so the operator set can\nonly be exactly the expected one - if the current operator set aggregated\npublic key subtracted by the non-signers public keys does not match the message\nsigners aggregated public key, then the message is not verifiable. If keeping\ntrack of signers was an option, a message from a previous operator set would\nstill be verifiable if at the current point it has enough quorum."}),"\n",(0,r.jsx)(t.p,{children:"Still, keeping track of signers makes it so there's not much of a benefit in\nusing BLS over ECDSA. So, in this case, moving to ECDSA would lead to some\nbenefits, and the only immediate tradeoff is the feasible operator set size.\nSince, in liveness terms, the operator set size must be limited, it should be\nrealistic to move to ECDSA as soon as EigenLayer offers support for it in their\nmiddleware contracts."})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var r=n(6540);const s={},i=r.createContext(s);function o(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);