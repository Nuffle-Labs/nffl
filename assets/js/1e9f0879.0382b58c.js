"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[860],{6135:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var t=s(4848),a=s(8453);const i={sidebar_position:2},o="Messaging and Checkpoints",r={id:"design/messaging_and_checkpoints",title:"Messaging and Checkpoints",description:"Please refer to Overview for an introduction.",source:"@site/docs/design/messaging_and_checkpoints.md",sourceDirName:"design",slug:"/design/messaging_and_checkpoints",permalink:"/design/messaging_and_checkpoints",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"sidebar",previous:{title:"Overview",permalink:"/design/overview"},next:{title:"Network Management",permalink:"/design/network_management"}},d={},l=[{value:"Terminology",id:"terminology",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Checkpoint Task",id:"checkpoint-task",level:2},{value:"NFFL Messages",id:"nffl-messages",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"messaging-and-checkpoints",children:"Messaging and Checkpoints"}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Please refer to ",(0,t.jsx)(n.a,{href:"/design/overview",children:"Overview"})," for an introduction."]})}),"\n",(0,t.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,t.jsxs)(n.p,{children:["There are two types of units of work that NFFL Operators must complete:\n",(0,t.jsx)(n.em,{children:"Messages"})," and ",(0,t.jsx)(n.em,{children:"Tasks"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Messages"})," are:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Generated by the operators in a distributed manner, there's no centralised\ncoordinator."}),"\n",(0,t.jsx)(n.li,{children:"Stored off-chain, since it's not cost and speed-effective to store them all\nindividually on-chain."}),"\n",(0,t.jsx)(n.li,{children:"Verified on demand, messages are not always verified on-chain - they should\nbe available for verification at all times, but it's not necessary that the\nattestation is submitted on-chain."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Tasks"})," are:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Generated by the ",(0,t.jsx)(n.em,{children:"Task Manager"})," on-chain, which must determine the work that\nshould be done and expect an answer from the operators."]}),"\n",(0,t.jsx)(n.li,{children:"Stored on-chain, Tasks are stored directly on the AVS contracts, and a\nresponse is expected to be submitted on-chain in a certain time range."}),"\n",(0,t.jsx)(n.li,{children:"Always verified on-chain, Operators response to Task are verified on-chain.\nFailed verification of a Task represents a protocol fault."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,t.jsxs)(n.p,{children:["EigenLayer's implementation of a Task is really similar to the definition\nabove. However, EigenLayer Task is not a good choice for keeping track of the\nwork done by the NFFL nodes. The main job of the NFFL node is to agree on state\nroot updates - i.e. block based progression of each participant network. If\neach of those updates was an (on-chain) Task, the NFFL would most likely not be\nfeasible in terms of operation cost and would also suffer a great blow in terms\nof a ",(0,t.jsx)(n.em,{children:"faster"})," finality."]}),"\n",(0,t.jsxs)(n.p,{children:["With this problem in mind, ",(0,t.jsx)(n.em,{children:"Message"})," was defined. It then enables high\nthroughput and most importantly essentially off-chain operations. However, it's\nstill necessary to formalize an on-chain unit of work - not only so the NFFL\nprogress is available on-chain but also to allow for fair slashing and payment\ndesigns."]}),"\n",(0,t.jsx)(n.h2,{id:"checkpoint-task",children:"Checkpoint Task"}),"\n",(0,t.jsxs)(n.p,{children:["In order to allow for the implementation of slashing and payment processes, the\nAVS Task was defined as a ",(0,t.jsx)(n.em,{children:"Checkpoint"})," Task."]}),"\n",(0,t.jsxs)(n.p,{children:["A Checkpoint Task is, essentially, comprised of the submission of a merkle root\nof the attested ",(0,t.jsx)(n.em,{children:"Messages"})," during a time range. Checkpoint Task are submitted\nat a regular cadence. Checkpoint Task not only provides a safe ledger to the\nAVS state, but also allows for establishing slashing and payment processes\nwhile keeping the NFFL cost of operation cheap."]}),"\n",(0,t.jsxs)(n.p,{children:["To facilitate the Checkpoint Task, the operators must then agree on all the\nMessages sent in that time period e.g. daily, and aggregate them into a ",(0,t.jsx)(n.a,{href:"https://docs.iden3.io/publications/pdfs/Merkle-Tree.pdf",children:"Sparse\nMerkle Tree (SMT)"}),".\nAnyone that has a copy of this SMT, can generate proofs of membership and\nnon-membership for any Message. This way, any Message that should've been\nattested can be verified and any message that shouldn't have been attested can\nalso be verified - leading to both punishments and also liveness tracking."]}),"\n",(0,t.jsx)(n.h2,{id:"nffl-messages",children:"NFFL Messages"}),"\n",(0,t.jsx)(n.p,{children:"There are two Messages in NFFL:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"StateRootUpdateMessage"}),": A state root update Message attests to the state\nroot of a network at a specific block height and timestamp."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"library StateRootUpdate {\n    struct Message {\n        uint32 rollupId;\n        uint64 blockHeight;\n        uint64 timestamp;\n        bytes32 nearDaTransactionId;\n        bytes32 nearDaCommitment;\n        bytes32 stateRoot;\n    }\n\n    // ...\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"OperatorSetUpdateMessage"}),": An operator set update message attests to an AVS\noperator set delta on Ethereum at a specific timestamp. All operator set\nupdates in a block are aggregated and attributed an auto-incrementing ID, and\ninclude all the operators whose weights changed."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-solidity",children:"library OperatorSetUpdate {\n    struct Message {\n        uint64 id;\n        uint64 timestamp;\n        Operators.Operator[] operators;\n    }\n\n    // ...\n}\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>r});var t=s(6540);const a={},i=t.createContext(a);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);