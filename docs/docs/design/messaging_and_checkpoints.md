---
sidebar_position: 2
---

# Messaging and Checkpoints

:::note

Please refer to [Overview](./overview.md) for an introduction.

:::

## Terminology

There are two types of units of work that SFFL Operators must complete:
_Messages_ and _Tasks_.

_Messages_ are:
* Generated by the operators in a distributed manner, there's no centralised
  coordinator.
* Stored off-chain, since it's not cost and speed-effective to store them all
  individually on-chain.
* Verified on demand, messages are not always verified on-chain - they should
  be available for verification at all times, but it's not necessary that the
  attestation is submitted on-chain.

_Tasks_ are:
* Generated by the _Task Manager_ on-chain must determine the work that should
  be done and expect an answer from the operators.
* Stored on-chain, Tasks are stored directly on the AVS contracts, and a
  response is expected to be submitted on-chain in a certain time range.
* Always verified on-chain, Operators response to Task are verified on-chain.
  Failed verification of a Task represents a protocol fault.

## Rationale

EigenLayer's implementation of a Task is really similar to the definition
above. However, EigenLayer Task is not a good choice for keeping track of the
work done by the SFFL nodes. The main job of the SFFL node is to agree on state
root updates - i.e. block based progression of each participant network. If
each of those updates was an (on-chain) Task, the SFFL would most likely not be
feasible in terms of operation cost and would also suffer a great blow in terms
of a _faster_ finality.

With this problem in mind, _Message_ was defined. It then enables high
throughput and most importantly essentially off-chain operations. However, it's
still necessary to formalize an on-chain unit of work - not only so the SFFL
progress is available on-chain but also to allow for fair slashing and payment
designs.

## Checkpoint Task

In order to allow for the implementation of slashing and payment processes, the
AVS Task was defined as a _Checkpoint_ Task.

A Checkpoint Task is comprised of the submission of a merkle root of the 
_Message_ type. Checkpoint Task are submitted at a regular cadence. Checkpoint
Task not only provides a safe ledger to the AVS state, but also allows for
establishing slashing and payment processes while keeping the SFFL cost of
operation cheap.

To facilitate the Checkpoint Task, the operators must then agree on all the
Messages sent in that time period e.g. daily, and aggregate them into a [Sparse
Merkle Tree (SMT)](https://docs.iden3.io/publications/pdfs/Merkle-Tree.pdf).
Anyone that has a copy of this SMT, can generate proofs of membership and
non-membership for any Message. This way, any Message that should've been
attested can be verified and any message that shouldn't have been attested can
also be verified - leading to both punishments and also liveness tracking.

## SFFL Messages

There are two Messages in SFFL:

* `StateRootUpdateMessage`: A state root update Message attests to the state
  root of a network at a specific block height and timestamp.

```solidity
library StateRootUpdate {
    struct Message {
        uint32 rollupId;
        uint64 blockHeight;
        uint64 timestamp;
        bytes32 stateRoot;
    }

    // ...
}
```

* `OperatorSetUpdateMessage`: An operator set update message attests to an AVS
  operator set delta on Ethereum at a specific timestamp. All operator set
  updates in a block are aggregated and attributed an auto-incrementing ID, and
  include all the operators whose weights changed.

```solidity
library OperatorSetUpdate {
    struct Message {
        uint64 id;
        uint64 timestamp;
        Operators.Operator[] operators;
    }

    // ...
}
```
